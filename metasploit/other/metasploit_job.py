import sqlite3

from pymetasploit3.msfrpc import MsfRpcClient
import dao.sqlite.msf_sqlite as db

HOST = 'host'
MODULE = 'module'
TYPE = 'type'
TARGETURI = 'uri'
PORT = 'port'

def msf_host_scanner(client: MsfRpcClient, host: str, threads: int) -> str:
    scanner = client.modules.use('auxiliary', 'scanner/portscan/tcp')
    scanner['RHOSTS'] = host
    scanner['THREADS'] = threads
    job_details = scanner.execute()
    return job_details['uuid']


class MetasploitJob:
    def __init__(self, password: str = 'Rn4klU6y', host: str = '127.0.0.1', port: int = 55552) -> None:
        """
        Initializes the Metasploit RPC client with provided credentials.

        Args:
            password (str): Password for authentication with the Metasploit RPC server.
            host (str): Host address of the Metasploit RPC server.
            port (int): Port on which the Metasploit RPC server is listening.
        """
        self._conn = db.create_connection()
        self.client = MsfRpcClient(password, host=host, port=port, ssl=True)

    def create_job(self, db_connection, table_name: str, data_json: dict) -> str:
        """
        Creates and executes a job on Metasploit based on the provided module and configuration.

        Args:
            data_json (dict): A dictionary containing necessary details like host, module type, and additional parameters.

        Returns:
            str: A string representation of the job's launch status including the job UUID and job information.

        Raises:
            ValueError: If essential keys are missing in the input dictionary.
        """
        required_keys = {'host', 'type', 'module'}
        if not required_keys.issubset(data_json.keys()):
            missing_keys = required_keys - set(data_json.keys())
            raise ValueError(f"Missing required keys in data_json: {missing_keys}")

        host = data_json[HOST]
        module = data_json[MODULE]
        type = data_json[TYPE]

        scanner = self.client.modules.use(type, module)
        scanner['RHOSTS'] = host

        # Optional parameters
        if 'port' in data_json:
            scanner['RPORT'] = data_json['port']
        if 'targeturi' in data_json:
            scanner['TARGETURI'] = data_json['targeturi']
        try:
            # Execute the scanner
            execute:dict = scanner.execute()  # scanner.execute() returns a dictionary: {'job_id': 0, 'uuid': 'zOC76S4ER0gMR7phkPoDtQaK'}

            if 'uuid' in execute.keys():
                uuid: str = execute['uuid']
                status: str = self.client.jobs.info_by_uuid(uuid)['status']
                db.insert_job(db_connection, table_name=table_name, uuid=uuid, host=host, module=module, status=status)
                return f"Launching status module: {module} on host: {host} -> {status}"

            if 'error' in execute.keys():
                return f"Launching status module: {module} on host: {host} has got error -> {execute}"
        except Exception as e:
            return (f"An unexpected error occurred: {e}")

    def check_jobs(self, db_connection, table_name) -> dict:
        """
        Checks and updates the status of jobs in a database table and records the results of completed jobs.

        This function performs the following operations:
        - Fetches UUIDs of jobs with the status 'running' and updates their status if they have changed.
        - Fetches UUIDs of jobs with the status 'completed' and stores their results if not already done.
        - Returns the count of running and completed jobs along with a descriptive message.

        Args:
            db_connection (sqlite3.Connection): The connection to the database.
            table_name (str): The name of the table in the database to query.

        Returns:
            dict: A dictionary containing the counts of running and completed jobs and a message.
        """

        # Retrieve a list of UUIDs for jobs that are currently running
        running_job_uuids: list = db.get_uuid_by_status(db_connection, table_name, status='running')

        # Check current status of each running job and update it in the database if it is not running anymore
        for uuid in running_job_uuids:
            info = self.client.jobs.info_by_uuid(uuid)
            if 'status' in info.keys() and info['status'] != 'running':
                db.set_status_by_uuid(db_connection, table_name, uuid, info['status'])

        # Retrieve a list of UUIDs for jobs that have been completed
        completed_job_uuids = db.get_uuid_by_status(db_connection, table_name, status='completed')

        # For each completed job, fetch and update the result if it has not been saved yet
        for uuid in completed_job_uuids:
            db_result = db.get_result_by_uuid(db_connection, table_name, uuid)
            if not db_result:
                msf_result = self.client.modules.results(uuid)
                if 'result' in msf_result.keys():
                    msf_result = msf_result['result']
                db.set_result_by_uuid(db_connection, table_name, uuid, msf_result)

        # Calculate the number of currently running jobs
        running_length: int = len(db.get_uuid_by_status(db_connection, table_name, 'running'))
        # Calculate the number of completed jobs
        completed_length: int = len(db.get_uuid_by_status(db_connection, table_name, 'completed'))

        # Return the counts and a descriptive message about the job statuses
        return {
            'running': running_length,
            'completed': completed_length,
            'message': f'There are {running_length} running jobs and {completed_length} completed jobs in {table_name} table!'
        }

    def get_results(self, table_name):
        return db.get_results_by_table_name(self._conn, table_name)


    def get_db_connection(self):
        """Return the database connection."""
        return self._conn

    def close_db_connection(self):
        """Close the database connection."""
        try:
            self._conn.close()
            print("Database connection successfully closed.")
        except sqlite3.Error as e:
            print(f"Error closing the database connection: {e}")